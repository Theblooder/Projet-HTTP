On accepte que des request line ! (unknown or invalid request method)

===== method =====
    GET / POST / PUT / HEAD / DELETE / CONNECT / OPTIONS / TRACE (sinon 501 Not Implmented) (GET et HEAD obligatoire)
    (si on connais mais client n'a pas le droit 405 (Method Not Allowed))
    (GET, HEAD, OPTIONS, TRACE are safe mathods) (PUT, DELETE et safe mathods are idempotent (on peut les faire plusieurs fois c'est pareil))


    Si GET :
        - pas de message body (400 Bad Resquest)

    Si HEAD :
        - pas de message body (400 Bad Resquest)

    Si POST :
        - vérifier que le payload vérifie bien le type de donnée envoyer voulu (A FAIRE POUR LE SPRINT 4)

    Si CONNECT :
        - request-target doit être un authority form
        - pas de message body (400 Bad Resquest)
    

==== resquest-target =====
    -If the port is equal to the default port for a scheme, the normal form is to omit the port subcomponent.
    
==== Transfer-Encoding-header =====
    - transfer-coding    = "chunked" ; Section 4.1
                        / "compress" ; Section 4.2.1
                        / "deflate" ; Section 4.2.2
                        / "gzip" ; Section 4.2.3
                        / transfer-extension   //verifié dans l'analyse syntaxique
                        
    - All transfer-coding names are case-insensitive and ought to be registered within the HTTP Transfer Coding registry
    - A recipient MUST ignore unrecognized chunk extensions.
    - A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, generate an appropriate       4xx (Client Error) response if that amount is exceeded.
    - A sender MUST NOT generate a trailer that contains a field necessary for message framing. 
    - When a chunked message containing a non-empty trailer is received, the recipient MAY process the fields (aside from those forbidden above) as if they were           appended to the message's header section.
    - A recipient MUST ignore (or consider as an error) any fields that are forbidden to be sent in a trailer.
    - a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.
    - A recipient SHOULD consider "x-compress" to be equivalent to "compress".
    - When the user agent generates an HTTP request, the user agent MUST NOT attach more than one Cookie header field.
    - If the user agent does attach a Cookie header field to an HTTP request, the user agent MUST send the cookie-string (defined below) as the value of the header       field.
    - The user agent MUST use an algorithm equivalent to the following
      algorithm to compute the "cookie-string" from a cookie store and a
      request-uri:

      1.  Let cookie-list be the set of cookies from the cookie store that
          meets all of the following requirements:

       *  Either:

             The cookie's host-only-flag is true and the canonicalized
             request-host is identical to the cookie's domain.

          Or:

             The cookie's host-only-flag is false and the canonicalized
             request-host domain-matches the cookie's domain.

       *  The request-uri's path path-matches the cookie's path.

       *  If the cookie's secure-only-flag is true, then the request-
          uri's scheme must denote a "secure" protocol (as defined by
          the user agent).
       *  If the cookie's http-only-flag is true, then exclude the
          cookie if the cookie-string is being generated for a "non-
          HTTP" API (as defined by the user agent).
     2.  The user agent SHOULD sort the cookie-list in the following
       order:

       *  Cookies with longer paths are listed before cookies with
          shorter paths.

       *  Among cookies that have equal-length path fields, cookies with
          earlier creation-times are listed before cookies with later
          creation-times.
   3.  Update the last-access-time of each cookie in the cookie-list to
       the current date and time.

   4.  Serialize the cookie-list into a cookie-string by processing each
       cookie in the cookie-list in order:

       1.  Output the cookie's name, the %x3D ("=") character, and the
           cookie's value.

       2.  If there is an unprocessed cookie in the cookie-list, output
           the characters %x3B and %x20 ("; ").
      
 ==== Referer-header ====
    - A user agent MUST NOT include the fragment and userinfo components of the URI reference
    - If the target URI was obtained from a source that does not have its own URI, the user agent MUST either exclude the
   Referer field or send it with a value of "about:blank".
    - An intermediary SHOULD NOT modify or delete the Referer header field when the field value shares the same scheme and host as the request target.

==== User-Agent =====
    - A user agent SHOULD NOT generate a User-Agent field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties.

==== Accept-header ==== 
    - A request without any Accept header field implies that the user agent will accept any media type in response.
    - If the header field is present in a request and none of the available representations for the response have a media type that is listed as acceptable, the           origin server can either honor the header field by sending a 406 (Not Acceptable) response or disregard the header field by treating the response as if it is       not subject to content negotiation.

==== Accept-Encoding-header ====
    - If an Accept-Encoding header field is present in a request and none of the available representations for the response have a content-coding that is listed as       acceptable, the origin server SHOULD send a response without any content-coding.
    
==== Content Length ====
    - A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.
    - a Content-Length header field is normally sent in a POST request even when the value is 0
    - A user agent SHOULD send a Content-Length in a request message when no Transfer-Encoding is sent and the request method defines a meaning for an enclosed           payload body.
    - A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate       such a body.
    - A server MAY send a Content-Length header field in a response to a HEAD request
    - a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload         body of a response if the same request had used the GET method.
    - A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request
    - a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload         body of a 200 (OK) response to the same request.
    - A server MUST NOT send a Content-Length header field in any response
      with a status code of 1xx (Informational) or 204 (No Content).
    - A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request
    - in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the payload body size is known prior to sending the             complete header section.
    - Since there is no predefined limit to the length of a payload, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due         to integer conversion overflows
    - If a message is received that has multiple Content-Length header
      fields with field-values consisting of the same decimal value, or a
      single Content-Length header field with a field value containing a
      list of identical decimal values (e.g., "Content-Length: 42, 42"),
      indicating that duplicate Content-Length header fields have been
      generated or combined by an upstream message processor, then the
      recipient MUST either reject the message as invalid or replace the
      duplicated field-values with a single valid Content-Length field
      containing that decimal value prior to determining the message body
      length or forwarding the message.
    
  ==== Message body length ====
    - https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3  //Every sentence in this section are rules so just check the RFC directly
    
  ==== Host header ====
    - origin form : When making a request directly to an origin server, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client
      MUST send only the absolute path and query components of the target URI as the request-target.  If the target URI's path component is empty, the client MUST         send "/" as the path within the origin-form of request-target.  A Host header field is also sent, as defined in Section 5.4.
    
    - absolute form : To allow for transition to the absolute-form for all requests in some future version of HTTP, a server MUST accept the absolute-form in             requests, even though HTTP/1.1 clients will only send them in requests to proxies.
    
    - authority form : When making a CONNECT request to establish a tunnel through one or more proxies, a client MUST send only the target URI's authority component       (excluding any userinfo and its "@" delimiter) as the request-target.
    
    - asterix form : When a client wishes to request OPTIONS for the server as a whole, as opposed to a specific named resource of that server, the client MUST
      send only "*" (%x2A) as the request-target.
      
    -Host: A client MUST send a Host header field in all HTTP/1.1 request messages. //Très important
    - If the target URI includes an authority component, then a client MUST send a field-value for Host that is identical to that authority component, excluding any       userinfo subcomponent and its "@" delimiter (Section 2.7.1).  If the authority component is missing or undefined for the target URI, then a client MUST send         Host header field with an empty field-value.
    - Since the Host field-value is critical information for handling a request, a user agent SHOULD generate Host as the first header field following the request-       line.
    - A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form
    - When a proxy receives a request with an absolute-form of
      request-target, the proxy MUST ignore the received Host header field
      (if any) and instead replace it with the host information of the
       request-target.  A proxy that forwards such a request MUST generate a
       new Host field-value based on the received request-target rather than
       forward the received Host field-value.
    - A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that           contains more than one Host header field or a Host header field with an invalid field-value.
    
    ==== Connection header ====
    - In order to avoid confusing downstream recipients, a proxy or gateway MUST remove or replace any received connection options before forwarding the message.
    - 

   
    
    

rfc3986 faire une fonction qui réécrit correctement le path

Si request-target est trop grand (414 URI Too Long) (faire au moins 8000 octets)

=== HTTP-version ===

si plus grand que 1.9 car 1.8 est traité comme du 1.1 (505 HTTP Version Not Supported)

si plus grand que 1.1 alors un champ HOST est obligatoire (400 Bad Request)


libmagick

conent-length et content-type